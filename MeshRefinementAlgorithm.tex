The following algorithm is used to generate an optimal triangulation
based on representation deficit refinement:

\subsection{Algorithm Specification}
\begin{algorithm}[H]
\begin{algorithmic}
\caption{Find optimal point for triangle splitting}
\Procedure{findOptimalPoint}{$t_i$} \Comment{for Triangle}
  \State $pattern \gets sizePattern\left( t_i \right)$
  \State $pattern \gets calculateTrianglePatternValues\left( t_i \right)$
  \State $minValue \gets determineMinPatternValue\left( pattern \right)$
  \While{$newTriangulationIsValid\left( minValue \right)$}
    \State $pattern \gets shiftPattern\left( minValue \right)$
    \State $pattern \gets calculateTrianglePatternValues\left( t_i \right)$
    \State $minValue \gets determineMinPatternValue\left( pattern \right)$
  \EndWhile
  \State $p_i \gets currentPatternValue\left( pattern \right)$
  \State $return \gets \left( p_i, minValue \right)$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}
\caption{Find optimal point for edge splitting}
\Procedure{findOptimalPoint}{$e_i$} \Comment{for Edge}
  \State $pattern \gets sizePattern\left( e_i \right)$
  \State $pattern \gets calculateEdgePatternValues\left( e_i \right)$
  \State $minValue \gets determineMinPatternValue\left( pattern \right)$
  \While{$newTriangulationIsValid\left( minValue \right)$}
    \State $pattern \gets shiftPattern\left( minValue \right)$
    \State $pattern \gets calculateEdgePatternValues\left( e_i \right)$
    \State $minValue \gets determineMinPatternValue\left( pattern \right)$
  \EndWhile
  \State $p_i \gets currentPatternValue\left( pattern \right)$
  \State $return \gets \left( p_i, minValue \right)$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Iterative Refinement}
\label{alg_IterativeRefinement}
\begin{algorithmic}
\Procedure{TriangleRefine}{$T$, $tol_{RD}$} \Comment{Refine the triangulation, $T$}
  \For{each triangle, $t_i$}
    \State $\left( p_i, minValue \right) \gets findOptimalPoint\left( t_i \right)$
    \If{$tooCloseToEdge\left( p_i, t_i \right)$}
      \State $e_i \gets findNearEdge\left( p_i, t_i \right)$
      \State $\left( p_i, minValue \right) \gets findOptimalPoint\left( e_i \right)$
      \State $operation \gets EdgeSplit\left( e_i, p_i \right)$
    \Else
      \State $operation \gets triangleSplit\left( t_i, p_i \right)$
    \EndIf
    \If{$minValue < tol_{RD}$}
      \State perform $operation$
    \EndIf
  \EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\begin{algorithmic}
\caption{Find the optimal point for node relocation}
\label{alg_NodeSmoothing}
\Procedure{findOptimalPoint}{$n_i$} \Comment{for Node}
  \State $pattern \gets sizePattern\left( n_i \right)$
  \State $pattern \gets calculateNodePatternValues\left( n_i \right)$
  \State $minValue \gets determineMinPatternValue\left( pattern \right)$
  \While{$newTriangulationIsValid\left( minValue \right)$}
    \State $pattern \gets shiftPattern\left( minValue \right)$
    \State $pattern \gets calculateNodePatternValues\left( n_i \right)$
    \State $minValue \gets determineMinPatternValue\left( pattern \right)$
  \EndWhile
  \State $p_i \gets currentPatternValue\left( pattern \right)$
  \State $return \gets \left( p_i, minValue \right)$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Nodal Smoothing}
\begin{algorithmic}
\Procedure{NodalSmooth}{$T$, $tol_{RD}$} \Comment{Smooth Node Positions}
  \For{each node, $n_i$}
    \State $pattern \gets sizePattern\left( e_i \right)$
    \State $pattern \gets calculateNodePatternValues\left( n_i \right)$
    \State $\left( p_i, minValue \right) \gets findOptimalPoint\left( e_i \right)$
  \EndFor
  \If{$minValue < tol_{RD}$}
    \State relocate $n_i$ to $p_i$
  \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}
